# -*- coding: utf-8 -*-
"""ENGR421-HW4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15V12kuZaFkiv1RZDvj5Bdgk6RJLCEQxZ
"""

import numpy as np
import pandas as pd
import math
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

dataset = pd.read_csv("/content/drive/MyDrive/hw04_data_set.csv").values.tolist()
dataset = np.asarray(dataset)

N = dataset.shape[0]

training_set = dataset[0:150]
print(training_set.shape)


test_set = dataset[150:len(dataset)]
print(test_set.shape)

bin_width = 0.37
origin = 1.5
last = np.max(dataset[:,[0]])

#borders for regressogram
left_borders = np.arange(origin, last, bin_width)
right_borders = np.arange(origin + bin_width, last + bin_width, bin_width)

"""#Regressogram"""

def regressogram():
  count = 0
  sum_ys = 0

  p_hats = np.zeros(len(left_borders))

  for k in range(len(left_borders)):
    for i in range(N):
      if dataset[i,[0]] > left_borders[k] and right_borders[k] >=  dataset[i,[0]]:
        count+=1
        sum_ys += dataset[i,[1]]

    if count>0:
      p_hats[k] = sum_ys/count
    else: 
      p_hats[k] = 0
    count = 0
    sum_ys = 0

  return p_hats

#plotting the data
plt.figure(figsize = (10, 5))
plt.plot(training_set[:,[0]], training_set[:,[1]], "b.", markersize = 10, label = "training")
plt.plot(test_set[:,[0]], test_set[:,[1]], "r.", markersize = 10, label = "test")
plt.legend()
plt.xlabel("Erruption time (min)")
plt.ylabel("Waiting time to next erruption (min)")


#implementing regressogram
p_hats = regressogram()

#ploting the regressogram
for b in range(len(left_borders)):
    plt.plot([left_borders[b], right_borders[b]], [p_hats[b], p_hats[b]], "k-")

for b in range(len(left_borders) - 1):
    plt.plot([right_borders[b], right_borders[b]], [p_hats[b], p_hats[b + 1]], "k-")

"""##RMSE"""

predicted_ys = []

for i in range(len(test_set)):
  for k in range(len(left_borders)):
      if test_set[i,[0]] > left_borders[k] and right_borders[k] >=  test_set[i,[0]]:
          predicted_ys.append(p_hats[k])


rmse_regressogram = np.sqrt(np.sum((np.squeeze(test_set[:,[1]]) - np.array(predicted_ys))**2) / len(test_set))
print("Regressogram => RMSE is ", rmse_regressogram, " when h is ", bin_width)

"""#Runing Mean Smoother"""

y_train = np.squeeze(training_set[:,[1]])
x_train = np.squeeze(training_set[:,[0]])
y_test = np.squeeze(test_set[:,[1]])
x_test = np.squeeze(test_set[:,[0]])

bin_values = [] #all y values in the bin are stored here
p_hats = []


for i in range(len(y_test)):
  for k in range(len(x_train)):
    if((abs(x_test[i]-x_train[k])/bin_width) <= 1/2):
      bin_values.append(y_train[k])
  result = np.sum(bin_values) / np.array(bin_values).shape[0]
  p_hats.append(result)
  bin_values = []

#plotting the data
plt.figure(figsize = (10, 5))
plt.plot(training_set[:,[0]], training_set[:,[1]], "b.", markersize = 10, label = "training")
plt.plot(test_set[:,[0]], test_set[:,[1]], "r.", markersize = 10, label = "test")
plt.legend()
plt.xlabel("Erruption time (min)")
plt.ylabel("Waiting time to next erruption (min)")

dataframe = pd.DataFrame({'x_test': x_test, 'p_hats': np.array(p_hats)})
dataframe = dataframe.sort_values(by = ['x_test'])

plt.plot( dataframe['x_test'], dataframe['p_hats'], "k-")

rmse_runningmean = np.sqrt(np.sum((y_test - p_hats)**2) / len(test_set))
print("Running Mean => RMSE is ", rmse_runningmean, " when h is ", bin_width)

"""#Kernel Smoother"""

sum = []
numerator = []
denominator = []
p_hats = []

for i in range(len(y_test)):
  for k in range(len(x_train)):
    u = (x_test[i]-x_train[k])/bin_width
    K = (1/math.sqrt(2*math.pi)) * np.exp(-1 * (u**2) / 2)
    numerator.append(K* y_train[k])
    denominator.append(K)

  result = np.sum(numerator) / np.sum(denominator)
  p_hats.append(result)

  numerator, denominator = [], []

#plotting the data
plt.figure(figsize = (10, 5))
plt.plot(training_set[:,[0]], training_set[:,[1]], "b.", markersize = 10, label = "training")
plt.plot(test_set[:,[0]], test_set[:,[1]], "r.", markersize = 10, label = "test")
plt.legend()
plt.xlabel("Erruption time (min)")
plt.ylabel("Waiting time to next erruption (min)")


dataframe = pd.DataFrame({'x_test': x_test, 'p_hats': np.array(p_hats)})
dataframe = dataframe.sort_values(by = ['x_test'])


plt.plot( dataframe['x_test'], dataframe['p_hats'], "k-")

rmse_kernelsmoother = np.sqrt(np.sum((y_test - p_hats)**2) / len(test_set))
print("Kernel Smoother => RMSE is ", rmse_kernelsmoother, " when h is ", bin_width)